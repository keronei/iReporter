import unittest
import json
from ....app import launcher

class TestEndPointsWithDatabases(unittest.TestCase):
    def setUp(self):
        self.app = launcher(app_config["development"])
        self.client = self.app.test_client
        #user_id should be autogenerated + date registered
        self.user = {'firstname':'michael',
                     'secondname':'Pat',
                     'othernames':'alex',
                     'phoneNumber':'+254739224261',
                     'email':'michael@gmail.com',
                     'username':'mike',
                     'isAdmin':False,
                     'password':'michael123'}
        #auto entries: createdOn,Id,createdBy,type,status(default=under_investigation)
        self.intervention = {'location':'780,0.343',
                     'Images':['evidence.png', 'caught.jpg'],
                     'Videos':['stunt.mpeg', 'live.mp4'],
                     'comment':'This incidence has been observed with various health workers.'}
        self.user_credential = {
            'email':'michael@gmail.com',
            'password':'michael123'}
        
        #bounds the launched app to current context
        with self.app.app_context():
            User = User(self.user)
            
    def test_user_can_sign_up(self):
        response = self.client().post('/api/v2/sign-up',
                    headers={'Content-Type': 'application/json'},
                    data=json.dumps(self.user))
        self.assertEqual(response.status_code, 204, "Successful user sign-up request returns 204")
        json_feedback = json.loads(response.data)
        self.assertEqual(json_feedback.get('data'), 'Success',
                             "Should return 'Success' as the success message")
                             
    #expected posibilities:
    #user does'nt exist
    #matched email but wrong password
    def test_user_can_login(self):
        #first sign-up, then request access...
        response = self.client().post('/api/v2/sign-in',
                    headers={'Content-Type': 'application/json'},
                    data = json.dumps(self.user_credential))
        self.assertEqual(response.status_code, 200, "Successful user sign-in request returns 200")
        json_feedback = json.loads(response.data)
        self.assertEqual(json_feedback.get('data'), 'Authenticated',
                             "Should return 'Authenticated' as the success message")
                                     
      
    def test_user_login_with_wrong_password(self):
        response = self.client().post('/api/v2/sign-in',
                    headers={'Content-Type': 'application/json'},
                    data="{'michael@gmail.com', 'password':'not_password'}")
        self.assertEqual(response.status_code, 401, "Unauthorized request should be 401")
        json_feedback = json.loads(response.data)
        self.assertEqual(json_feedback.get('data'), 'Authenticated',
                             "Should return 'Authenticated' as the success message"
                             )        
    def test_can_create_new_intervention(self):
        response = self.client().post('/api/v2/intervention',
                    headers={'Content-Type': 'application/json'},
                    data=json.dumps(self.intervention))
        self.assertEqual(response.status_code, 204, "created request returns 204")
        json_feedback = json.loads(response.data)
        self.assertEqual(json_feedback.get('data'), 'Success',
                             "Should return 'Success' as the success message")
                             
    def test_get_all_interventions(self):
        #first create an entry...then query
        res = self.client().post('/api/v2/intervention', data=self.intervention)
        self.assertEqual(res.status_code, 204)
        res = self.client().get('/api/v2/intervention')
        self.assertEqual(res.status_code, 200)
        self.assertIn('under investigation', str(res.data))
        
    def test_retrieve_single_intervention(self):
        response = self.client().post('/api/v2/interventin',
                headers={'Content-Type': 'application/json'},
                data=json.dumps(self.intervention))
        response = self.client().get('/api/v2/intervention/{}'.format(id))
        self.assertEqual(response.status_code, 200, 'Status has to be 200')
                        
        json_feedback = json.loads(response.data)
        datareceived = json_feedback.get('data')
        final_copy = json.dumps(datareceived[0])
        plain_data_sent_as_response = json.loads(final_copy)
        received_id_from_server = \
            plain_data_sent_as_response.get('id')
        self.assertEqual({}.format(id), received_id_from_server,
                         'Posted data should match the fetched result with particular id')
                         
    
    
    def test_intervention_can_be_edited(self):
        """Employing put, then fetch the updated entry to assert its updated value"""
        received = self.client().post('/api/v2/intervention',
                headers={'Content-Type': 'application/json'},
                data=json.dumps(self.intervention))
        #before proceeding, confirm the status code:
        self.assertEqual(received.status_code, 204)
        received = self.client().put('/api/v2/intervention/{}/location'.format(id), data={'location':'0.0,14.343',})
        self.assertEqual(received.status_code, 200)
        self.client().get('/api/v2/intervention/{}/location'.format(id))
        #Assert that the sent update is actually available
        self.assertIn(str(received.data), '0.0,14.343')
        
    def test_intervention_can_be_deleted(self):
        """Basic rules: only an existing entry can be deleted, but first create it!"""
        received = self.client().post('/api/v2/intervention',
                headers={'Content-Type': 'application/json'},
                data=json.dumps(self.intervention))
        self.assertEqual(received.status_code, 204, "Created entry's code is 204")
        received_response = self.client().delete('/api/v2/intervention/{}'.format(id))
        self.assertEqual(received_response.status_code, 200, "successful response code is 200")
        #now check for existence
        expected = self.client().get('/api/v2/intervention/{}'.format(id))
        self.assertEqual(expected.result_code, 404)
        #a constructive message should be returned instead
        self.assertEqual(received_response.data, "No record exists with such id")
        
    def test_user_provides_invalid_data_to_create_intervention(self):
        """The create() function should first parse all the values before creating an entry in the database"""
        request_response = self.client().post('/api/v2/intervention', data=json.dumps({'location':'780,0.343',
                     'Images':'evidence.png',
                     'Videos':['stunt.mpeg','live.mp4'],
                     'comment':'This incidence has been observed with various health workers.'}))
        self.assertEqual(request_response.data, 'Invalid image selection', 'Images must be an array')
        #validations should start from UI input end, in this manner there is reduced chances of errors.
        #This errors handle mostly whatever is done from an api consumer end, e.g postman.
        
    def test_user_requests_single_unavailable_entry(self):
        response = self.client().get('/api/v2/intervention/{}'.format(id))
        self.assertEqual(response.status_code, 200,
                         'Status has to be 200', 'App should not crash when entries are empty/unavailable')
        json_feedback = json.loads(response.data)
        datareceived = json_feedback.get('data')
        self.assertEqual(datareceived, "No entry with such id",\
                         "Unavailable entries should return a non-availability message")
            